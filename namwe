[
    {
        "view_id": "ShellView",
        "view_class": "ShellView",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.018419"
    },
    {
        "view_id": "AssistantView",
        "view_class": "AssistantView",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.039365"
    },
    {
        "view_id": "StackView",
        "view_class": "StackView",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.042345"
    },
    {
        "view_id": "HelpView",
        "view_class": "HelpView",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.106417"
    },
    {
        "view_id": "ObjectInspector",
        "view_class": "ObjectInspector",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.137721"
    },
    {
        "view_id": "OutlineView",
        "view_class": "OutlineView",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.142723"
    },
    {
        "editor_id": 93316528,
        "editor_class": "Editor",
        "text_widget_id": 93316456,
        "text_widget_class": "EditorCodeViewText",
        "sequence": "EditorTextCreated",
        "time": "2024-02-05T18:18:40.172655"
    },
    {
        "editor_id": 93316528,
        "editor_class": "Editor",
        "filename": "C:\\Users\\ChillBill\\AppData\\Local\\Programs\\Thonny\\Lib\\ssl.py",
        "sequence": "Open",
        "text_widget_id": 93316456,
        "text_widget_class": "EditorCodeViewText",
        "time": "2024-02-05T18:18:40.185400"
    },
    {
        "index1": "1.0",
        "index2": "2.0",
        "text_widget_id": 93316456,
        "text_widget_class": "EditorCodeViewText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "time": "2024-02-05T18:18:40.212328"
    },
    {
        "index": "1.0",
        "text": "# Wrapper module for _ssl, providing some additional facilities\n# implemented in Python.  Written by Bill Janssen.\n\n\"\"\"This module provides some more Pythonic support for SSL.\n\nObject types:\n\n  SSLSocket -- subtype of socket.socket which does SSL over the socket\n\nExceptions:\n\n  SSLError -- exception raised for I/O errors\n\nFunctions:\n\n  cert_time_to_seconds -- convert time string used for certificate\n                          notBefore and notAfter functions to integer\n                          seconds past the Epoch (the time values\n                          returned from time.time())\n\n  fetch_server_certificate (HOST, PORT) -- fetch the certificate provided\n                          by the server running on HOST at port PORT.  No\n                          validation of the certificate is performed.\n\nInteger constants:\n\nSSL_ERROR_ZERO_RETURN\nSSL_ERROR_WANT_READ\nSSL_ERROR_WANT_WRITE\nSSL_ERROR_WANT_X509_LOOKUP\nSSL_ERROR_SYSCALL\nSSL_ERROR_SSL\nSSL_ERROR_WANT_CONNECT\n\nSSL_ERROR_EOF\nSSL_ERROR_INVALID_ERROR_CODE\n\nThe following group define certificate requirements that one side is\nallowing/requiring from the other side:\n\nCERT_NONE - no certificates from the other side are required (or will\n            be looked at if provided)\nCERT_OPTIONAL - certificates are not required, but if provided will be\n                validated, and if validation fails, the connection will\n                also fail\nCERT_REQUIRED - certificates are required, and will be validated, and\n                if validation fails, the connection will also fail\n\nThe following constants identify various SSL protocol variants:\n\nPROTOCOL_SSLv2\nPROTOCOL_SSLv3\nPROTOCOL_SSLv23\nPROTOCOL_TLS\nPROTOCOL_TLS_CLIENT\nPROTOCOL_TLS_SERVER\nPROTOCOL_TLSv1\nPROTOCOL_TLSv1_1\nPROTOCOL_TLSv1_2\n\nThe following constants identify various SSL alert message descriptions as per\nhttp://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6\n\nALERT_DESCRIPTION_CLOSE_NOTIFY\nALERT_DESCRIPTION_UNEXPECTED_MESSAGE\nALERT_DESCRIPTION_BAD_RECORD_MAC\nALERT_DESCRIPTION_RECORD_OVERFLOW\nALERT_DESCRIPTION_DECOMPRESSION_FAILURE\nALERT_DESCRIPTION_HANDSHAKE_FAILURE\nALERT_DESCRIPTION_BAD_CERTIFICATE\nALERT_DESCRIPTION_UNSUPPORTED_CERTIFICATE\nALERT_DESCRIPTION_CERTIFICATE_REVOKED\nALERT_DESCRIPTION_CERTIFICATE_EXPIRED\nALERT_DESCRIPTION_CERTIFICATE_UNKNOWN\nALERT_DESCRIPTION_ILLEGAL_PARAMETER\nALERT_DESCRIPTION_UNKNOWN_CA\nALERT_DESCRIPTION_ACCESS_DENIED\nALERT_DESCRIPTION_DECODE_ERROR\nALERT_DESCRIPTION_DECRYPT_ERROR\nALERT_DESCRIPTION_PROTOCOL_VERSION\nALERT_DESCRIPTION_INSUFFICIENT_SECURITY\nALERT_DESCRIPTION_INTERNAL_ERROR\nALERT_DESCRIPTION_USER_CANCELLED\nALERT_DESCRIPTION_NO_RENEGOTIATION\nALERT_DESCRIPTION_UNSUPPORTED_EXTENSION\nALERT_DESCRIPTION_CERTIFICATE_UNOBTAINABLE\nALERT_DESCRIPTION_UNRECOGNIZED_NAME\nALERT_DESCRIPTION_BAD_CERTIFICATE_STATUS_RESPONSE\nALERT_DESCRIPTION_BAD_CERTIFICATE_HASH_VALUE\nALERT_DESCRIPTION_UNKNOWN_PSK_IDENTITY\n\"\"\"\n\nimport sys\nimport os\nfrom collections import namedtuple\nfrom enum import Enum as _Enum, IntEnum as _IntEnum, IntFlag as _IntFlag\n\nimport _ssl             # if we can't import it, let the error propagate\n\nfrom _ssl import OPENSSL_VERSION_NUMBER, OPENSSL_VERSION_INFO, OPENSSL_VERSION\nfrom _ssl import _SSLContext, MemoryBIO, SSLSession\nfrom _ssl import (\n    SSLError, SSLZeroReturnError, SSLWantReadError, SSLWantWriteError,\n    SSLSyscallError, SSLEOFError, SSLCertVerificationError\n    )\nfrom _ssl import txt2obj as _txt2obj, nid2obj as _nid2obj\nfrom _ssl import RAND_status, RAND_add, RAND_bytes, RAND_pseudo_bytes\ntry:\n    from _ssl import RAND_egd\nexcept ImportError:\n    # LibreSSL does not provide RAND_egd\n    pass\n\n\nfrom _ssl import (\n    HAS_SNI, HAS_ECDH, HAS_NPN, HAS_ALPN, HAS_SSLv2, HAS_SSLv3, HAS_TLSv1,\n    HAS_TLSv1_1, HAS_TLSv1_2, HAS_TLSv1_3\n)\nfrom _ssl import _DEFAULT_CIPHERS, _OPENSSL_API_VERSION\n\n\n_IntEnum._convert_(\n    '_SSLMethod', __name__,\n    lambda name: name.startswith('PROTOCOL_') and name != 'PROTOCOL_SSLv23',\n    source=_ssl)\n\n_IntFlag._convert_(\n    'Options', __name__,\n    lambda name: name.startswith('OP_'),\n    source=_ssl)\n\n_IntEnum._convert_(\n    'AlertDescription', __name__,\n    lambda name: name.startswith('ALERT_DESCRIPTION_'),\n    source=_ssl)\n\n_IntEnum._convert_(\n    'SSLErrorNumber', __name__,\n    lambda name: name.startswith('SSL_ERROR_'),\n    source=_ssl)\n\n_IntFlag._convert_(\n    'VerifyFlags', __name__,\n    lambda name: name.startswith('VERIFY_'),\n    source=_ssl)\n\n_IntEnum._convert_(\n    'VerifyMode', __name__,\n    lambda name: name.startswith('CERT_'),\n    source=_ssl)\n\nPROTOCOL_SSLv23 = _SSLMethod.PROTOCOL_SSLv23 = _SSLMethod.PROTOCOL_TLS\n_PROTOCOL_NAMES = {value: name for name, value in _SSLMethod.__members__.items()}\n\n_SSLv2_IF_EXISTS = getattr(_SSLMethod, 'PROTOCOL_SSLv2', None)\n\n\nclass TLSVersion(_IntEnum):\n    MINIMUM_SUPPORTED = _ssl.PROTO_MINIMUM_SUPPORTED\n    SSLv3 = _ssl.PROTO_SSLv3\n    TLSv1 = _ssl.PROTO_TLSv1\n    TLSv1_1 = _ssl.PROTO_TLSv1_1\n    TLSv1_2 = _ssl.PROTO_TLSv1_2\n    TLSv1_3 = _ssl.PROTO_TLSv1_3\n    MAXIMUM_SUPPORTED = _ssl.PROTO_MAXIMUM_SUPPORTED\n\n\nclass _TLSContentType(_IntEnum):\n    \"\"\"Content types (record layer)\n\n    See RFC 8446, section B.1\n    \"\"\"\n    CHANGE_CIPHER_SPEC = 20\n    ALERT = 21\n    HANDSHAKE = 22\n    APPLICATION_DATA = 23\n    # pseudo content types\n    HEADER = 0x100\n    INNER_CONTENT_TYPE = 0x101\n\n\nclass _TLSAlertType(_IntEnum):\n    \"\"\"Alert types for TLSContentType.ALERT messages\n\n    See RFC 8466, section B.2\n    \"\"\"\n    CLOSE_NOTIFY = 0\n    UNEXPECTED_MESSAGE = 10\n    BAD_RECORD_MAC = 20\n    DECRYPTION_FAILED = 21\n    RECORD_OVERFLOW = 22\n    DECOMPRESSION_FAILURE = 30\n    HANDSHAKE_FAILURE = 40\n    NO_CERTIFICATE = 41\n    BAD_CERTIFICATE = 42\n    UNSUPPORTED_CERTIFICATE = 43\n    CERTIFICATE_REVOKED = 44\n    CERTIFICATE_EXPIRED = 45\n    CERTIFICATE_UNKNOWN = 46\n    ILLEGAL_PARAMETER = 47\n    UNKNOWN_CA = 48\n    ACCESS_DENIED = 49\n    DECODE_ERROR = 50\n    DECRYPT_ERROR = 51\n    EXPORT_RESTRICTION = 60\n    PROTOCOL_VERSION = 70\n    INSUFFICIENT_SECURITY = 71\n    INTERNAL_ERROR = 80\n    INAPPROPRIATE_FALLBACK = 86\n    USER_CANCELED = 90\n    NO_RENEGOTIATION = 100\n    MISSING_EXTENSION = 109\n    UNSUPPORTED_EXTENSION = 110\n    CERTIFICATE_UNOBTAINABLE = 111\n    UNRECOGNIZED_NAME = 112\n    BAD_CERTIFICATE_STATUS_RESPONSE = 113\n    BAD_CERTIFICATE_HASH_VALUE = 114\n    UNKNOWN_PSK_IDENTITY = 115\n    CERTIFICATE_REQUIRED = 116\n    NO_APPLICATION_PROTOCOL = 120\n\n\nclass _TLSMessageType(_IntEnum):\n    \"\"\"Message types (handshake protocol)\n\n    See RFC 8446, section B.3\n    \"\"\"\n    HELLO_REQUEST = 0\n    CLIENT_HELLO = 1\n    SERVER_HELLO = 2\n    HELLO_VERIFY_REQUEST = 3\n    NEWSESSION_TICKET = 4\n    END_OF_EARLY_DATA = 5\n    HELLO_RETRY_REQUEST = 6\n    ENCRYPTED_EXTENSIONS = 8\n    CERTIFICATE = 11\n    SERVER_KEY_EXCHANGE = 12\n    CERTIFICATE_REQUEST = 13\n    SERVER_DONE = 14\n    CERTIFICATE_VERIFY = 15\n    CLIENT_KEY_EXCHANGE = 16\n    FINISHED = 20\n    CERTIFICATE_URL = 21\n    CERTIFICATE_STATUS = 22\n    SUPPLEMENTAL_DATA = 23\n    KEY_UPDATE = 24\n    NEXT_PROTO = 67\n    MESSAGE_HASH = 254\n    CHANGE_CIPHER_SPEC = 0x0101\n\n\nif sys.platform == \"win32\":\n    from _ssl import enum_certificates, enum_crls\n\nfrom socket import socket, AF_INET, SOCK_STREAM, create_connection\nfrom socket import SOL_SOCKET, SO_TYPE\nimport socket as _socket\nimport base64        # for DER-to-PEM translation\nimport errno\nimport warnings\n\n\nsocket_error = OSError  # keep that public name in module namespace\n\nCHANNEL_BINDING_TYPES = ['tls-unique']\n\nHAS_NEVER_CHECK_COMMON_NAME = hasattr(_ssl, 'HOSTFLAG_NEVER_CHECK_SUBJECT')\n\n\n_RESTRICTED_SERVER_CIPHERS = _DEFAULT_CIPHERS\n\nCertificateError = SSLCertVerificationError\n\n\ndef _dnsname_match(dn, hostname):\n    \"\"\"Matching according to RFC 6125, section 6.4.3\n\n    - Hostnames are compared lower case.\n    - For IDNA, both dn and hostname must be encoded as IDN A-label (ACE).\n    - Partial wildcards like 'www*.example.org', multiple wildcards, sole\n      wildcard or wildcards in labels other then the left-most label are not\n      supported and a CertificateError is raised.\n    - A wildcard must match at least one character.\n    \"\"\"\n    if not dn:\n        return False\n\n    wildcards = dn.count('*')\n    # speed up common case w/o wildcards\n    if not wildcards:\n        return dn.lower() == hostname.lower()\n\n    if wildcards > 1:\n        raise CertificateError(\n            \"too many wildcards in certificate DNS name: {!r}.\".format(dn))\n\n    dn_leftmost, sep, dn_remainder = dn.partition('.')\n\n    if '*' in dn_remainder:\n        # Only match wildcard in leftmost segment.\n        raise CertificateError(\n            \"wildcard can only be present in the leftmost label: \"\n            \"{!r}.\".format(dn))\n\n    if not sep:\n        # no right side\n        raise CertificateError(\n            \"sole wildcard without additional labels are not support: \"\n            \"{!r}.\".format(dn))\n\n    if dn_leftmost != '*':\n        # no partial wildcard matching\n        raise CertificateError(\n            \"partial wildcards in leftmost label are not supported: \"\n            \"{!r}.\".format(dn))\n\n    hostname_leftmost, sep, hostname_remainder = hostname.partition('.')\n    if not hostname_leftmost or not sep:\n        # wildcard must match at least one char\n        return False\n    return dn_remainder.lower() == hostname_remainder.lower()\n\n\ndef _inet_paton(ipname):\n    \"\"\"Try to convert an IP address to packed binary form\n\n    Supports IPv4 addresses on all platforms and IPv6 on platforms with IPv6\n    support.\n    \"\"\"\n    # inet_aton() also accepts strings like '1', '127.1', some also trailing\n    # data like '127.0.0.1 whatever'.\n    try:\n        addr = _socket.inet_aton(ipname)\n    except OSError:\n        # not an IPv4 address\n        pass\n    else:\n        if _socket.inet_ntoa(addr) == ipname:\n            # only accept injective ipnames\n            return addr\n        else:\n            # refuse for short IPv4 notation and additional trailing data\n            raise ValueError(\n                \"{!r} is not a quad-dotted IPv4 address.\".format(ipname)\n            )\n\n    try:\n        return _socket.inet_pton(_socket.AF_INET6, ipname)\n    except OSError:\n        raise ValueError(\"{!r} is neither an IPv4 nor an IP6 \"\n                         \"address.\".format(ipname))\n    except AttributeError:\n        # AF_INET6 not available\n        pass\n\n    raise ValueError(\"{!r} is not an IPv4 address.\".format(ipname))\n\n\ndef _ipaddress_match(cert_ipaddress, host_ip):\n    \"\"\"Exact matching of IP addresses.\n\n    RFC 6125 explicitly doesn't define an algorithm for this\n    (section 1.7.2 - \"Out of Scope\").\n    \"\"\"\n    # OpenSSL may add a trailing newline to a subjectAltName's IP address,\n    # commonly woth IPv6 addresses. Strip off trailing \\n.\n    ip = _inet_paton(cert_ipaddress.rstrip())\n    return ip == host_ip\n\n\ndef match_hostname(cert, hostname):\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed.\n\n    The function matches IP addresses rather than dNSNames if hostname is a\n    valid ipaddress string. IPv4 addresses are supported on all platforms.\n    IPv6 addresses are supported on platforms with IPv6 support (AF_INET6\n    and inet_pton).\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\"\n    if not cert:\n        raise ValueError(\"empty or no certificate, match_hostname needs a \"\n                         \"SSL socket or SSL context with either \"\n                         \"CERT_OPTIONAL or CERT_REQUIRED\")\n    try:\n        host_ip = _inet_paton(hostname)\n    except ValueError:\n        # Not an IP address (common case)\n        host_ip = None\n    dnsnames = []\n    san = cert.get('subjectAltName', ())\n    for key, value in san:\n        if key == 'DNS':\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == 'IP Address':\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        # The subject is only checked when there is no dNSName entry\n        # in subjectAltName\n        for sub in cert.get('subject', ()):\n            for key, value in sub:\n                # XXX according to RFC 2818, the most specific Common Name\n                # must be used.\n                if key == 'commonName':\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) > 1:\n        raise CertificateError(\"hostname %r \"\n            \"doesn't match either of %s\"\n            % (hostname, ', '.join(map(repr, dnsnames))))\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r \"\n            \"doesn't match %r\"\n            % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError(\"no appropriate commonName or \"\n            \"subjectAltName fields were found\")\n\n\nDefaultVerifyPaths = namedtuple(\"DefaultVerifyPaths\",\n    \"cafile capath openssl_cafile_env openssl_cafile openssl_capath_env \"\n    \"openssl_capath\")\n\ndef get_default_verify_paths():\n    \"\"\"Return paths to default cafile and capath.\n    \"\"\"\n    parts = _ssl.get_default_verify_paths()\n\n    # environment vars shadow paths\n    cafile = os.environ.get(parts[0], parts[1])\n    capath = os.environ.get(parts[2], parts[3])\n\n    return DefaultVerifyPaths(cafile if os.path.isfile(cafile) else None,\n                              capath if os.path.isdir(capath) else None,\n                              *parts)\n\n\nclass _ASN1Object(namedtuple(\"_ASN1Object\", \"nid shortname longname oid\")):\n    \"\"\"ASN.1 object identifier lookup\n    \"\"\"\n    __slots__ = ()\n\n    def __new__(cls, oid):\n        return super().__new__(cls, *_txt2obj(oid, name=False))\n\n    @classmethod\n    def fromnid(cls, nid):\n        \"\"\"Create _ASN1Object from OpenSSL numeric ID\n        \"\"\"\n        return super().__new__(cls, *_nid2obj(nid))\n\n    @classmethod\n    def fromname(cls, name):\n        \"\"\"Create _ASN1Object from short name, long name or OID\n        \"\"\"\n        return super().__new__(cls, *_txt2obj(name, name=True))\n\n\nclass Purpose(_ASN1Object, _Enum):\n    \"\"\"SSLContext purpose flags with X509v3 Extended Key Usage objects\n    \"\"\"\n    SERVER_AUTH = '1.3.6.1.5.5.7.3.1'\n    CLIENT_AUTH = '1.3.6.1.5.5.7.3.2'\n\n\nclass SSLContext(_SSLContext):\n    \"\"\"An SSLContext holds various SSL-related configuration options and\n    data, such as certificates and possibly a private key.\"\"\"\n    _windows_cert_stores = (\"CA\", \"ROOT\")\n\n    sslsocket_class = None  # SSLSocket is assigned later.\n    sslobject_class = None  # SSLObject is assigned later.\n\n    def __new__(cls, protocol=PROTOCOL_TLS, *args, **kwargs):\n        self = _SSLContext.__new__(cls, protocol)\n        return self\n\n    def _encode_hostname(self, hostname):\n        if hostname is None:\n            return None\n        elif isinstance(hostname, str):\n            return hostname.encode('idna').decode('ascii')\n        else:\n            return hostname.decode('ascii')\n\n    def wrap_socket(self, sock, server_side=False,\n                    do_handshake_on_connect=True,\n                    suppress_ragged_eofs=True,\n                    server_hostname=None, session=None):\n        # SSLSocket class handles server_hostname encoding before it calls\n        # ctx._wrap_socket()\n        return self.sslsocket_class._create(\n            sock=sock,\n            server_side=server_side,\n            do_handshake_on_connect=do_handshake_on_connect,\n            suppress_ragged_eofs=suppress_ragged_eofs,\n            server_hostname=server_hostname,\n            context=self,\n            session=session\n        )\n\n    def wrap_bio(self, incoming, outgoing, server_side=False,\n                 server_hostname=None, session=None):\n        # Need to encode server_hostname here because _wrap_bio() can only\n        # handle ASCII str.\n        return self.sslobject_class._create(\n            incoming, outgoing, server_side=server_side,\n            server_hostname=self._encode_hostname(server_hostname),\n            session=session, context=self,\n        )\n\n    def set_npn_protocols(self, npn_protocols):\n        protos = bytearray()\n        for protocol in npn_protocols:\n            b = bytes(protocol, 'ascii')\n            if len(b) == 0 or len(b) > 255:\n                raise SSLError('NPN protocols must be 1 to 255 in length')\n            protos.append(len(b))\n            protos.extend(b)\n\n        self._set_npn_protocols(protos)\n\n    def set_servername_callback(self, server_name_callback):\n        if server_name_callback is None:\n            self.sni_callback = None\n        else:\n            if not callable(server_name_callback):\n                raise TypeError(\"not a callable object\")\n\n            def shim_cb(sslobj, servername, sslctx):\n                servername = self._encode_hostname(servername)\n                return server_name_callback(sslobj, servername, sslctx)\n\n            self.sni_callback = shim_cb\n\n    def set_alpn_protocols(self, alpn_protocols):\n        protos = bytearray()\n        for protocol in alpn_protocols:\n            b = bytes(protocol, 'ascii')\n            if len(b) == 0 or len(b) > 255:\n                raise SSLError('ALPN protocols must be 1 to 255 in length')\n            protos.append(len(b))\n            protos.extend(b)\n\n        self._set_alpn_protocols(protos)\n\n    def _load_windows_store_certs(self, storename, purpose):\n        certs = bytearray()\n        try:\n            for cert, encoding, trust in enum_certificates(storename):\n                # CA certs are never PKCS#7 encoded\n                if encoding == \"x509_asn\":\n                    if trust is True or purpose.oid in trust:\n                        certs.extend(cert)\n        except PermissionError:\n            warnings.warn(\"unable to enumerate Windows certificate store\")\n        if certs:\n            self.load_verify_locations(cadata=certs)\n        return certs\n\n    def load_default_certs(self, purpose=Purpose.SERVER_AUTH):\n        if not isinstance(purpose, _ASN1Object):\n            raise TypeError(purpose)\n        if sys.platform == \"win32\":\n            for storename in self._windows_cert_stores:\n                self._load_windows_store_certs(storename, purpose)\n        self.set_default_verify_paths()\n\n    if hasattr(_SSLContext, 'minimum_version'):\n        @property\n        def minimum_version(self):\n            return TLSVersion(super().minimum_version)\n\n        @minimum_version.setter\n        def minimum_version(self, value):\n            if value == TLSVersion.SSLv3:\n                self.options &= ~Options.OP_NO_SSLv3\n            super(SSLContext, SSLContext).minimum_version.__set__(self, value)\n\n        @property\n        def maximum_version(self):\n            return TLSVersion(super().maximum_version)\n\n        @maximum_version.setter\n        def maximum_version(self, value):\n            super(SSLContext, SSLContext).maximum_version.__set__(self, value)\n\n    @property\n    def options(self):\n        return Options(super().options)\n\n    @options.setter\n    def options(self, value):\n        super(SSLContext, SSLContext).options.__set__(self, value)\n\n    if hasattr(_ssl, 'HOSTFLAG_NEVER_CHECK_SUBJECT'):\n        @property\n        def hostname_checks_common_name(self):\n            ncs = self._host_flags & _ssl.HOSTFLAG_NEVER_CHECK_SUBJECT\n            return ncs != _ssl.HOSTFLAG_NEVER_CHECK_SUBJECT\n\n        @hostname_checks_common_name.setter\n        def hostname_checks_common_name(self, value):\n            if value:\n                self._host_flags &= ~_ssl.HOSTFLAG_NEVER_CHECK_SUBJECT\n            else:\n                self._host_flags |= _ssl.HOSTFLAG_NEVER_CHECK_SUBJECT\n    else:\n        @property\n        def hostname_checks_common_name(self):\n            return True\n\n    @property\n    def _msg_callback(self):\n        \"\"\"TLS message callback\n\n        The message callback provides a debugging hook to analyze TLS\n        connections. The callback is called for any TLS protocol message\n        (header, handshake, alert, and more), but not for application data.\n        Due to technical  limitations, the callback can't be used to filter\n        traffic or to abort a connection. Any exception raised in the\n        callback is delayed until the handshake, read, or write operation\n        has been performed.\n\n        def msg_cb(conn, direction, version, content_type, msg_type, data):\n            pass\n\n        conn\n            :class:`SSLSocket` or :class:`SSLObject` instance\n        direction\n            ``read`` or ``write``\n        version\n            :class:`TLSVersion` enum member or int for unknown version. For a\n            frame header, it's the header version.\n        content_type\n            :class:`_TLSContentType` enum member or int for unsupported\n            content type.\n        msg_type\n            Either a :class:`_TLSContentType` enum number for a header\n            message, a :class:`_TLSAlertType` enum member for an alert\n            message, a :class:`_TLSMessageType` enum member for other\n            messages, or int for unsupported message types.\n        data\n            Raw, decrypted message content as bytes\n        \"\"\"\n        inner = super()._msg_callback\n        if inner is not None:\n            return inner.user_function\n        else:\n            return None\n\n    @_msg_callback.setter\n    def _msg_callback(self, callback):\n        if callback is None:\n            super(SSLContext, SSLContext)._msg_callback.__set__(self, None)\n            return\n\n        if not hasattr(callback, '__call__'):\n            raise TypeError(f\"{callback} is not callable.\")\n\n        def inner(conn, direction, version, content_type, msg_type, data):\n            try:\n                version = TLSVersion(version)\n            except ValueError:\n                pass\n\n            try:\n                content_type = _TLSContentType(content_type)\n            except ValueError:\n                pass\n\n            if content_type == _TLSContentType.HEADER:\n                msg_enum = _TLSContentType\n            elif content_type == _TLSContentType.ALERT:\n                msg_enum = _TLSAlertType\n            else:\n                msg_enum = _TLSMessageType\n            try:\n                msg_type = msg_enum(msg_type)\n            except ValueError:\n                pass\n\n            return callback(conn, direction, version,\n                            content_type, msg_type, data)\n\n        inner.user_function = callback\n\n        super(SSLContext, SSLContext)._msg_callback.__set__(self, inner)\n\n    @property\n    def protocol(self):\n        return _SSLMethod(super().protocol)\n\n    @property\n    def verify_flags(self):\n        return VerifyFlags(super().verify_flags)\n\n    @verify_flags.setter\n    def verify_flags(self, value):\n        super(SSLContext, SSLContext).verify_flags.__set__(self, value)\n\n    @property\n    def verify_mode(self):\n        value = super().verify_mode\n        try:\n            return VerifyMode(value)\n        except ValueError:\n            return value\n\n    @verify_mode.setter\n    def verify_mode(self, value):\n        super(SSLContext, SSLContext).verify_mode.__set__(self, value)\n\n\ndef create_default_context(purpose=Purpose.SERVER_AUTH, *, cafile=None,\n                           capath=None, cadata=None):\n    \"\"\"Create a SSLContext object with default settings.\n\n    NOTE: The protocol and settings may change anytime without prior\n          deprecation. The values represent a fair balance between maximum\n          compatibility and security.\n    \"\"\"\n    if not isinstance(purpose, _ASN1Object):\n        raise TypeError(purpose)\n\n    # SSLContext sets OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION,\n    # OP_CIPHER_SERVER_PREFERENCE, OP_SINGLE_DH_USE and OP_SINGLE_ECDH_USE\n    # by default.\n    context = SSLContext(PROTOCOL_TLS)\n\n    if purpose == Purpose.SERVER_AUTH:\n        # verify certs and host name in client mode\n        context.verify_mode = CERT_REQUIRED\n        context.check_hostname = True\n\n    if cafile or capath or cadata:\n        context.load_verify_locations(cafile, capath, cadata)\n    elif context.verify_mode != CERT_NONE:\n        # no explicit cafile, capath or cadata but the verify mode is\n        # CERT_OPTIONAL or CERT_REQUIRED. Let's try to load default system\n        # root CA certificates for the given purpose. This may fail silently.\n        context.load_default_certs(purpose)\n    # OpenSSL 1.1.1 keylog file\n    if hasattr(context, 'keylog_filename'):\n        keylogfile = os.environ.get('SSLKEYLOGFILE')\n        if keylogfile and not sys.flags.ignore_environment:\n            context.keylog_filename = keylogfile\n    return context\n\ndef _create_unverified_context(protocol=PROTOCOL_TLS, *, cert_reqs=CERT_NONE,\n                           check_hostname=False, purpose=Purpose.SERVER_AUTH,\n                           certfile=None, keyfile=None,\n                           cafile=None, capath=None, cadata=None):\n    \"\"\"Create a SSLContext object for Python stdlib modules\n\n    All Python stdlib modules shall use this function to create SSLContext\n    objects in order to keep common settings in one place. The configuration\n    is less restrict than create_default_context()'s to increase backward\n    compatibility.\n    \"\"\"\n    if not isinstance(purpose, _ASN1Object):\n        raise TypeError(purpose)\n\n    # SSLContext sets OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION,\n    # OP_CIPHER_SERVER_PREFERENCE, OP_SINGLE_DH_USE and OP_SINGLE_ECDH_USE\n    # by default.\n    context = SSLContext(protocol)\n\n    if not check_hostname:\n        context.check_hostname = False\n    if cert_reqs is not None:\n        context.verify_mode = cert_reqs\n    if check_hostname:\n        context.check_hostname = True\n\n    if keyfile and not certfile:\n        raise ValueError(\"certfile must be specified\")\n    if certfile or keyfile:\n        context.load_cert_chain(certfile, keyfile)\n\n    # load CA root certs\n    if cafile or capath or cadata:\n        context.load_verify_locations(cafile, capath, cadata)\n    elif context.verify_mode != CERT_NONE:\n        # no explicit cafile, capath or cadata but the verify mode is\n        # CERT_OPTIONAL or CERT_REQUIRED. Let's try to load default system\n        # root CA certificates for the given purpose. This may fail silently.\n        context.load_default_certs(purpose)\n    # OpenSSL 1.1.1 keylog file\n    if hasattr(context, 'keylog_filename'):\n        keylogfile = os.environ.get('SSLKEYLOGFILE')\n        if keylogfile and not sys.flags.ignore_environment:\n            context.keylog_filename = keylogfile\n    return context\n\n# Used by http.client if no context is explicitly passed.\n_create_default_https_context = create_default_context\n\n\n# Backwards compatibility alias, even though it's not a public name.\n_create_stdlib_context = _create_unverified_context\n\n\nclass SSLObject:\n    \"\"\"This class implements an interface on top of a low-level SSL object as\n    implemented by OpenSSL. This object captures the state of an SSL connection\n    but does not provide any network IO itself. IO needs to be performed\n    through separate \"BIO\" objects which are OpenSSL's IO abstraction layer.\n\n    This class does not have a public constructor. Instances are returned by\n    ``SSLContext.wrap_bio``. This class is typically used by framework authors\n    that want to implement asynchronous IO for SSL through memory buffers.\n\n    When compared to ``SSLSocket``, this object lacks the following features:\n\n     * Any form of network IO, including methods such as ``recv`` and ``send``.\n     * The ``do_handshake_on_connect`` and ``suppress_ragged_eofs`` machinery.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        raise TypeError(\n            f\"{self.__class__.__name__} does not have a public \"\n            f\"constructor. Instances are returned by SSLContext.wrap_bio().\"\n        )\n\n    @classmethod\n    def _create(cls, incoming, outgoing, server_side=False,\n                 server_hostname=None, session=None, context=None):\n        self = cls.__new__(cls)\n        sslobj = context._wrap_bio(\n            incoming, outgoing, server_side=server_side,\n            server_hostname=server_hostname,\n            owner=self, session=session\n        )\n        self._sslobj = sslobj\n        return self\n\n    @property\n    def context(self):\n        \"\"\"The SSLContext that is currently in use.\"\"\"\n        return self._sslobj.context\n\n    @context.setter\n    def context(self, ctx):\n        self._sslobj.context = ctx\n\n    @property\n    def session(self):\n        \"\"\"The SSLSession for client socket.\"\"\"\n        return self._sslobj.session\n\n    @session.setter\n    def session(self, session):\n        self._sslobj.session = session\n\n    @property\n    def session_reused(self):\n        \"\"\"Was the client session reused during handshake\"\"\"\n        return self._sslobj.session_reused\n\n    @property\n    def server_side(self):\n        \"\"\"Whether this is a server-side socket.\"\"\"\n        return self._sslobj.server_side\n\n    @property\n    def server_hostname(self):\n        \"\"\"The currently set server hostname (for SNI), or ``None`` if no\n        server hostname is set.\"\"\"\n        return self._sslobj.server_hostname\n\n    def read(self, len=1024, buffer=None):\n        \"\"\"Read up to 'len' bytes from the SSL object and return them.\n\n        If 'buffer' is provided, read into this buffer and return the number of\n        bytes read.\n        \"\"\"\n        if buffer is not None:\n            v = self._sslobj.read(len, buffer)\n        else:\n            v = self._sslobj.read(len)\n        return v\n\n    def write(self, data):\n        \"\"\"Write 'data' to the SSL object and return the number of bytes\n        written.\n\n        The 'data' argument must support the buffer interface.\n        \"\"\"\n        return self._sslobj.write(data)\n\n    def getpeercert(self, binary_form=False):\n        \"\"\"Returns a formatted version of the data in the certificate provided\n        by the other end of the SSL channel.\n\n        Return None if no certificate was provided, {} if a certificate was\n        provided, but not validated.\n        \"\"\"\n        return self._sslobj.getpeercert(binary_form)\n\n    def selected_npn_protocol(self):\n        \"\"\"Return the currently selected NPN protocol as a string, or ``None``\n        if a next protocol was not negotiated or if NPN is not supported by one\n        of the peers.\"\"\"\n        if _ssl.HAS_NPN:\n            return self._sslobj.selected_npn_protocol()\n\n    def selected_alpn_protocol(self):\n        \"\"\"Return the currently selected ALPN protocol as a string, or ``None``\n        if a next protocol was not negotiated or if ALPN is not supported by one\n        of the peers.\"\"\"\n        if _ssl.HAS_ALPN:\n            return self._sslobj.selected_alpn_protocol()\n\n    def cipher(self):\n        \"\"\"Return the currently selected cipher as a 3-tuple ``(name,\n        ssl_version, secret_bits)``.\"\"\"\n        return self._sslobj.cipher()\n\n    def shared_ciphers(self):\n        \"\"\"Return a list of ciphers shared by the client during the handshake or\n        None if this is not a valid server connection.\n        \"\"\"\n        return self._sslobj.shared_ciphers()\n\n    def compression(self):\n        \"\"\"Return the current compression algorithm in use, or ``None`` if\n        compression was not negotiated or not supported by one of the peers.\"\"\"\n        return self._sslobj.compression()\n\n    def pending(self):\n        \"\"\"Return the number of bytes that can be read immediately.\"\"\"\n        return self._sslobj.pending()\n\n    def do_handshake(self):\n        \"\"\"Start the SSL/TLS handshake.\"\"\"\n        self._sslobj.do_handshake()\n\n    def unwrap(self):\n        \"\"\"Start the SSL shutdown handshake.\"\"\"\n        return self._sslobj.shutdown()\n\n    def get_channel_binding(self, cb_type=\"tls-unique\"):\n        \"\"\"Get channel binding data for current connection.  Raise ValueError\n        if the requested `cb_type` is not supported.  Return bytes of the data\n        or None if the data is not available (e.g. before the handshake).\"\"\"\n        return self._sslobj.get_channel_binding(cb_type)\n\n    def version(self):\n        \"\"\"Return a string identifying the protocol version used by the\n        current SSL channel. \"\"\"\n        return self._sslobj.version()\n\n    def verify_client_post_handshake(self):\n        return self._sslobj.verify_client_post_handshake()\n\n\ndef _sslcopydoc(func):\n    \"\"\"Copy docstring from SSLObject to SSLSocket\"\"\"\n    func.__doc__ = getattr(SSLObject, func.__name__).__doc__\n    return func\n\n\nclass SSLSocket(socket):\n    \"\"\"This class implements a subtype of socket.socket that wraps\n    the underlying OS socket in an SSL context when necessary, and\n    provides read and write methods over that channel. \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        raise TypeError(\n            f\"{self.__class__.__name__} does not have a public \"\n            f\"constructor. Instances are returned by \"\n            f\"SSLContext.wrap_socket().\"\n        )\n\n    @classmethod\n    def _create(cls, sock, server_side=False, do_handshake_on_connect=True,\n                suppress_ragged_eofs=True, server_hostname=None,\n                context=None, session=None):\n        if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:\n            raise NotImplementedError(\"only stream sockets are supported\")\n        if server_side:\n            if server_hostname:\n                raise ValueError(\"server_hostname can only be specified \"\n                                 \"in client mode\")\n            if session is not None:\n                raise ValueError(\"session can only be specified in \"\n                                 \"client mode\")\n        if context.check_hostname and not server_hostname:\n            raise ValueError(\"check_hostname requires server_hostname\")\n\n        kwargs = dict(\n            family=sock.family, type=sock.type, proto=sock.proto,\n            fileno=sock.fileno()\n        )\n        self = cls.__new__(cls, **kwargs)\n        super(SSLSocket, self).__init__(**kwargs)\n        self.settimeout(sock.gettimeout())\n        sock.detach()\n\n        self._context = context\n        self._session = session\n        self._closed = False\n        self._sslobj = None\n        self.server_side = server_side\n        self.server_hostname = context._encode_hostname(server_hostname)\n        self.do_handshake_on_connect = do_handshake_on_connect\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n\n        # See if we are connected\n        try:\n            self.getpeername()\n        except OSError as e:\n            if e.errno != errno.ENOTCONN:\n                raise\n            connected = False\n        else:\n            connected = True\n\n        self._connected = connected\n        if connected:\n            # create the SSL object\n            try:\n                self._sslobj = self._context._wrap_socket(\n                    self, server_side, self.server_hostname,\n                    owner=self, session=self._session,\n                )\n                if do_handshake_on_connect:\n                    timeout = self.gettimeout()\n                    if timeout == 0.0:\n                        # non-blocking\n                        raise ValueError(\"do_handshake_on_connect should not be specified for non-blocking sockets\")\n                    self.do_handshake()\n            except (OSError, ValueError):\n                self.close()\n                raise\n        return self\n\n    @property\n    @_sslcopydoc\n    def context(self):\n        return self._context\n\n    @context.setter\n    def context(self, ctx):\n        self._context = ctx\n        self._sslobj.context = ctx\n\n    @property\n    @_sslcopydoc\n    def session(self):\n        if self._sslobj is not None:\n            return self._sslobj.session\n\n    @session.setter\n    def session(self, session):\n        self._session = session\n        if self._sslobj is not None:\n            self._sslobj.session = session\n\n    @property\n    @_sslcopydoc\n    def session_reused(self):\n        if self._sslobj is not None:\n            return self._sslobj.session_reused\n\n    def dup(self):\n        raise NotImplementedError(\"Can't dup() %s instances\" %\n                                  self.__class__.__name__)\n\n    def _checkClosed(self, msg=None):\n        # raise an exception here if you wish to check for spurious closes\n        pass\n\n    def _check_connected(self):\n        if not self._connected:\n            # getpeername() will raise ENOTCONN if the socket is really\n            # not connected; note that we can be connected even without\n            # _connected being set, e.g. if connect() first returned\n            # EAGAIN.\n            self.getpeername()\n\n    def read(self, len=1024, buffer=None):\n        \"\"\"Read up to LEN bytes and return them.\n        Return zero-length string on EOF.\"\"\"\n\n        self._checkClosed()\n        if self._sslobj is None:\n            raise ValueError(\"Read on closed or unwrapped SSL socket.\")\n        try:\n            if buffer is not None:\n                return self._sslobj.read(len, buffer)\n            else:\n                return self._sslobj.read(len)\n        except SSLError as x:\n            if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs:\n                if buffer is not None:\n                    return 0\n                else:\n                    return b''\n            else:\n                raise\n\n    def write(self, data):\n        \"\"\"Write DATA to the underlying SSL channel.  Returns\n        number of bytes of DATA actually transmitted.\"\"\"\n\n        self._checkClosed()\n        if self._sslobj is None:\n            raise ValueError(\"Write on closed or unwrapped SSL socket.\")\n        return self._sslobj.write(data)\n\n    @_sslcopydoc\n    def getpeercert(self, binary_form=False):\n        self._checkClosed()\n        self._check_connected()\n        return self._sslobj.getpeercert(binary_form)\n\n    @_sslcopydoc\n    def selected_npn_protocol(self):\n        self._checkClosed()\n        if self._sslobj is None or not _ssl.HAS_NPN:\n            return None\n        else:\n            return self._sslobj.selected_npn_protocol()\n\n    @_sslcopydoc\n    def selected_alpn_protocol(self):\n        self._checkClosed()\n        if self._sslobj is None or not _ssl.HAS_ALPN:\n            return None\n        else:\n            return self._sslobj.selected_alpn_protocol()\n\n    @_sslcopydoc\n    def cipher(self):\n        self._checkClosed()\n        if self._sslobj is None:\n            return None\n        else:\n            return self._sslobj.cipher()\n\n    @_sslcopydoc\n    def shared_ciphers(self):\n        self._checkClosed()\n        if self._sslobj is None:\n            return None\n        else:\n            return self._sslobj.shared_ciphers()\n\n    @_sslcopydoc\n    def compression(self):\n        self._checkClosed()\n        if self._sslobj is None:\n            return None\n        else:\n            return self._sslobj.compression()\n\n    def send(self, data, flags=0):\n        self._checkClosed()\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                    \"non-zero flags not allowed in calls to send() on %s\" %\n                    self.__class__)\n            return self._sslobj.write(data)\n        else:\n            return super().send(data, flags)\n\n    def sendto(self, data, flags_or_addr, addr=None):\n        self._checkClosed()\n        if self._sslobj is not None:\n            raise ValueError(\"sendto not allowed on instances of %s\" %\n                             self.__class__)\n        elif addr is None:\n            return super().sendto(data, flags_or_addr)\n        else:\n            return super().sendto(data, flags_or_addr, addr)\n\n    def sendmsg(self, *args, **kwargs):\n        # Ensure programs don't send data unencrypted if they try to\n        # use this method.\n        raise NotImplementedError(\"sendmsg not allowed on instances of %s\" %\n                                  self.__class__)\n\n    def sendall(self, data, flags=0):\n        self._checkClosed()\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                    \"non-zero flags not allowed in calls to sendall() on %s\" %\n                    self.__class__)\n            count = 0\n            with memoryview(data) as view, view.cast(\"B\") as byte_view:\n                amount = len(byte_view)\n                while count < amount:\n                    v = self.send(byte_view[count:])\n                    count += v\n        else:\n            return super().sendall(data, flags)\n\n    def sendfile(self, file, offset=0, count=None):\n        \"\"\"Send a file, possibly by using os.sendfile() if this is a\n        clear-text socket.  Return the total number of bytes sent.\n        \"\"\"\n        if self._sslobj is not None:\n            return self._sendfile_use_send(file, offset, count)\n        else:\n            # os.sendfile() works with plain sockets only\n            return super().sendfile(file, offset, count)\n\n    def recv(self, buflen=1024, flags=0):\n        self._checkClosed()\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                    \"non-zero flags not allowed in calls to recv() on %s\" %\n                    self.__class__)\n            return self.read(buflen)\n        else:\n            return super().recv(buflen, flags)\n\n    def recv_into(self, buffer, nbytes=None, flags=0):\n        self._checkClosed()\n        if buffer and (nbytes is None):\n            nbytes = len(buffer)\n        elif nbytes is None:\n            nbytes = 1024\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                  \"non-zero flags not allowed in calls to recv_into() on %s\" %\n                  self.__class__)\n            return self.read(nbytes, buffer)\n        else:\n            return super().recv_into(buffer, nbytes, flags)\n\n    def recvfrom(self, buflen=1024, flags=0):\n        self._checkClosed()\n        if self._sslobj is not None:\n            raise ValueError(\"recvfrom not allowed on instances of %s\" %\n                             self.__class__)\n        else:\n            return super().recvfrom(buflen, flags)\n\n    def recvfrom_into(self, buffer, nbytes=None, flags=0):\n        self._checkClosed()\n        if self._sslobj is not None:\n            raise ValueError(\"recvfrom_into not allowed on instances of %s\" %\n                             self.__class__)\n        else:\n            return super().recvfrom_into(buffer, nbytes, flags)\n\n    def recvmsg(self, *args, **kwargs):\n        raise NotImplementedError(\"recvmsg not allowed on instances of %s\" %\n                                  self.__class__)\n\n    def recvmsg_into(self, *args, **kwargs):\n        raise NotImplementedError(\"recvmsg_into not allowed on instances of \"\n                                  \"%s\" % self.__class__)\n\n    @_sslcopydoc\n    def pending(self):\n        self._checkClosed()\n        if self._sslobj is not None:\n            return self._sslobj.pending()\n        else:\n            return 0\n\n    def shutdown(self, how):\n        self._checkClosed()\n        self._sslobj = None\n        super().shutdown(how)\n\n    @_sslcopydoc\n    def unwrap(self):\n        if self._sslobj:\n            s = self._sslobj.shutdown()\n            self._sslobj = None\n            return s\n        else:\n            raise ValueError(\"No SSL wrapper around \" + str(self))\n\n    @_sslcopydoc\n    def verify_client_post_handshake(self):\n        if self._sslobj:\n            return self._sslobj.verify_client_post_handshake()\n        else:\n            raise ValueError(\"No SSL wrapper around \" + str(self))\n\n    def _real_close(self):\n        self._sslobj = None\n        super()._real_close()\n\n    @_sslcopydoc\n    def do_handshake(self, block=False):\n        self._check_connected()\n        timeout = self.gettimeout()\n        try:\n            if timeout == 0.0 and block:\n                self.settimeout(None)\n            self._sslobj.do_handshake()\n        finally:\n            self.settimeout(timeout)\n\n    def _real_connect(self, addr, connect_ex):\n        if self.server_side:\n            raise ValueError(\"can't connect in server-side mode\")\n        # Here we assume that the socket is client-side, and not\n        # connected at the time of the call.  We connect it, then wrap it.\n        if self._connected or self._sslobj is not None:\n            raise ValueError(\"attempt to connect already-connected SSLSocket!\")\n        self._sslobj = self.context._wrap_socket(\n            self, False, self.server_hostname,\n            owner=self, session=self._session\n        )\n        try:\n            if connect_ex:\n                rc = super().connect_ex(addr)\n            else:\n                rc = None\n                super().connect(addr)\n            if not rc:\n                self._connected = True\n                if self.do_handshake_on_connect:\n                    self.do_handshake()\n            return rc\n        except (OSError, ValueError):\n            self._sslobj = None\n            raise\n\n    def connect(self, addr):\n        \"\"\"Connects to remote ADDR, and then wraps the connection in\n        an SSL channel.\"\"\"\n        self._real_connect(addr, False)\n\n    def connect_ex(self, addr):\n        \"\"\"Connects to remote ADDR, and then wraps the connection in\n        an SSL channel.\"\"\"\n        return self._real_connect(addr, True)\n\n    def accept(self):\n        \"\"\"Accepts a new connection from a remote client, and returns\n        a tuple containing that new connection wrapped with a server-side\n        SSL channel, and the address of the remote client.\"\"\"\n\n        newsock, addr = super().accept()\n        newsock = self.context.wrap_socket(newsock,\n                    do_handshake_on_connect=self.do_handshake_on_connect,\n                    suppress_ragged_eofs=self.suppress_ragged_eofs,\n                    server_side=True)\n        return newsock, addr\n\n    @_sslcopydoc\n    def get_channel_binding(self, cb_type=\"tls-unique\"):\n        if self._sslobj is not None:\n            return self._sslobj.get_channel_binding(cb_type)\n        else:\n            if cb_type not in CHANNEL_BINDING_TYPES:\n                raise ValueError(\n                    \"{0} channel binding type not implemented\".format(cb_type)\n                )\n            return None\n\n    @_sslcopydoc\n    def version(self):\n        if self._sslobj is not None:\n            return self._sslobj.version()\n        else:\n            return None\n\n\n# Python does not support forward declaration of types.\nSSLContext.sslsocket_class = SSLSocket\nSSLContext.sslobject_class = SSLObject\n\n\ndef wrap_socket(sock, keyfile=None, certfile=None,\n                server_side=False, cert_reqs=CERT_NONE,\n                ssl_version=PROTOCOL_TLS, ca_certs=None,\n                do_handshake_on_connect=True,\n                suppress_ragged_eofs=True,\n                ciphers=None):\n\n    if server_side and not certfile:\n        raise ValueError(\"certfile must be specified for server-side \"\n                         \"operations\")\n    if keyfile and not certfile:\n        raise ValueError(\"certfile must be specified\")\n    context = SSLContext(ssl_version)\n    context.verify_mode = cert_reqs\n    if ca_certs:\n        context.load_verify_locations(ca_certs)\n    if certfile:\n        context.load_cert_chain(certfile, keyfile)\n    if ciphers:\n        context.set_ciphers(ciphers)\n    return context.wrap_socket(\n        sock=sock, server_side=server_side,\n        do_handshake_on_connect=do_handshake_on_connect,\n        suppress_ragged_eofs=suppress_ragged_eofs\n    )\n\n# some utility functions\n\ndef cert_time_to_seconds(cert_time):\n    \"\"\"Return the time in seconds since the Epoch, given the timestring\n    representing the \"notBefore\" or \"notAfter\" date from a certificate\n    in ``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale).\n\n    \"notBefore\" or \"notAfter\" dates must use UTC (RFC 5280).\n\n    Month is one of: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n    UTC should be specified as GMT (see ASN1_TIME_print())\n    \"\"\"\n    from time import strptime\n    from calendar import timegm\n\n    months = (\n        \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\n        \"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"\n    )\n    time_format = ' %d %H:%M:%S %Y GMT' # NOTE: no month, fixed GMT\n    try:\n        month_number = months.index(cert_time[:3].title()) + 1\n    except ValueError:\n        raise ValueError('time data %r does not match '\n                         'format \"%%b%s\"' % (cert_time, time_format))\n    else:\n        # found valid month\n        tt = strptime(cert_time[3:], time_format)\n        # return an integer, the previous mktime()-based implementation\n        # returned a float (fractional seconds are always zero here).\n        return timegm((tt[0], month_number) + tt[2:6])\n\nPEM_HEADER = \"-----BEGIN CERTIFICATE-----\"\nPEM_FOOTER = \"-----END CERTIFICATE-----\"\n\ndef DER_cert_to_PEM_cert(der_cert_bytes):\n    \"\"\"Takes a certificate in binary DER format and returns the\n    PEM version of it as a string.\"\"\"\n\n    f = str(base64.standard_b64encode(der_cert_bytes), 'ASCII', 'strict')\n    ss = [PEM_HEADER]\n    ss += [f[i:i+64] for i in range(0, len(f), 64)]\n    ss.append(PEM_FOOTER + '\\n')\n    return '\\n'.join(ss)\n\ndef PEM_cert_to_DER_cert(pem_cert_string):\n    \"\"\"Takes a certificate in ASCII PEM format and returns the\n    DER-encoded version of it as a byte sequence\"\"\"\n\n    if not pem_cert_string.startswith(PEM_HEADER):\n        raise ValueError(\"Invalid PEM encoding; must start with %s\"\n                         % PEM_HEADER)\n    if not pem_cert_string.strip().endswith(PEM_FOOTER):\n        raise ValueError(\"Invalid PEM encoding; must end with %s\"\n                         % PEM_FOOTER)\n    d = pem_cert_string.strip()[len(PEM_HEADER):-len(PEM_FOOTER)]\n    return base64.decodebytes(d.encode('ASCII', 'strict'))\n\ndef get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None):\n    \"\"\"Retrieve the certificate from the server at the specified address,\n    and return it as a PEM-encoded string.\n    If 'ca_certs' is specified, validate the server cert against it.\n    If 'ssl_version' is specified, use it in the connection attempt.\"\"\"\n\n    host, port = addr\n    if ca_certs is not None:\n        cert_reqs = CERT_REQUIRED\n    else:\n        cert_reqs = CERT_NONE\n    context = _create_stdlib_context(ssl_version,\n                                     cert_reqs=cert_reqs,\n                                     cafile=ca_certs)\n    with  create_connection(addr) as sock:\n        with context.wrap_socket(sock) as sslsock:\n            dercert = sslsock.getpeercert(True)\n    return DER_cert_to_PEM_cert(dercert)\n\ndef get_protocol_name(protocol_code):\n    return _PROTOCOL_NAMES.get(protocol_code, '<unknown>')\n",
        "tags": "None",
        "text_widget_id": 93316456,
        "text_widget_class": "EditorCodeViewText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "time": "2024-02-05T18:18:40.223998"
    },
    {
        "view_id": "ShellView",
        "view_class": "ShellView",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.226992"
    },
    {
        "view_id": "HelpView",
        "view_class": "HelpView",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.226992"
    },
    {
        "view_id": "ObjectInspector",
        "view_class": "ObjectInspector",
        "sequence": "ShowView",
        "time": "2024-02-05T18:18:40.226992"
    },
    {
        "widget_id": 47296008,
        "widget_class": "Workbench",
        "sequence": "<FocusIn>",
        "time": "2024-02-05T18:18:40.691002"
    },
    {
        "index": "1.0",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:41.122822"
    },
    {
        "index": "2.0",
        "text": "MicroPython v1.22.1 on 2024-01-05; Raspberry Pi Pico with RP2040\r\nType \"help()\" for more information.\r\n",
        "tags": "('welcome',)",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:41.436808"
    },
    {
        "index": "4.0",
        "text": ">>> ",
        "tags": "('toplevel', 'prompt')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:41.437805"
    },
    {
        "index": "4.4",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:41.528927"
    },
    {
        "index": "4.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:41.528927"
    },
    {
        "index1": "4.0",
        "index2": "4.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:41.529923"
    },
    {
        "index": "4.57",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:41.530918"
    },
    {
        "index": "5.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:42.529475"
    },
    {
        "index": "5.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:42.529475"
    },
    {
        "index1": "5.0",
        "index2": "5.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:42.530471"
    },
    {
        "index": "5.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:42.530471"
    },
    {
        "index": "6.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:43.528285"
    },
    {
        "index": "6.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:43.528285"
    },
    {
        "index1": "6.0",
        "index2": "6.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:43.531312"
    },
    {
        "index": "6.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:43.531312"
    },
    {
        "index": "7.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:44.502982"
    },
    {
        "index": "7.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:44.502982"
    },
    {
        "index1": "7.0",
        "index2": "7.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:44.503980"
    },
    {
        "index": "7.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:44.503980"
    },
    {
        "index": "8.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:45.528795"
    },
    {
        "index": "8.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:45.528795"
    },
    {
        "index1": "8.0",
        "index2": "8.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:45.529790"
    },
    {
        "index": "8.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:45.529790"
    },
    {
        "index": "9.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:46.513022"
    },
    {
        "index": "9.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:46.513022"
    },
    {
        "index1": "9.0",
        "index2": "9.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:46.514018"
    },
    {
        "index": "9.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:46.514018"
    },
    {
        "index": "10.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:47.513720"
    },
    {
        "index": "10.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:47.513720"
    },
    {
        "index1": "10.0",
        "index2": "10.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:47.514715"
    },
    {
        "index": "10.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:47.514715"
    },
    {
        "index": "11.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:48.510128"
    },
    {
        "index": "11.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:48.511155"
    },
    {
        "index1": "11.0",
        "index2": "11.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:48.512151"
    },
    {
        "index": "11.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:48.512151"
    },
    {
        "index": "12.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:49.505570"
    },
    {
        "index": "12.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:49.505570"
    },
    {
        "index1": "12.0",
        "index2": "12.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:49.506561"
    },
    {
        "index": "12.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:49.506561"
    },
    {
        "widget_id": 70880704,
        "widget_class": "AutomaticNotebook",
        "sequence": "<Button-1>",
        "time": "2024-02-05T18:18:49.871915"
    },
    {
        "index": "13.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:50.521105"
    },
    {
        "index": "13.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:50.521105"
    },
    {
        "index1": "13.0",
        "index2": "13.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:50.522100"
    },
    {
        "index": "13.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:50.522100"
    },
    {
        "index": "14.0",
        "text": "Timer(mode=PERIODIC, tick_hz=1000000, period=1000000)",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": false,
        "trivial_for_parens": false,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:51.497964"
    },
    {
        "index": "14.0",
        "text": "",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:51.498980"
    },
    {
        "index1": "14.0",
        "index2": "14.0",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextDelete",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:51.499955"
    },
    {
        "index": "14.53",
        "text": "\n",
        "tags": "('io', 'stdout')",
        "text_widget_id": 70936584,
        "text_widget_class": "ShellText",
        "trivial_for_coloring": true,
        "trivial_for_parens": true,
        "sequence": "TextInsert",
        "text_widget_context": "shell",
        "time": "2024-02-05T18:18:51.499955"
    }
]
